// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/box2d"

// Values
fn aabb_center(AABB) -> Vec2

fn aabb_contains(AABB, AABB) -> Bool

fn aabb_extents(AABB) -> Vec2

fn aabb_overlap(AABB, AABB) -> Bool

fn aabb_overlaps(AABB, AABB) -> Bool

fn aabb_perimeter(AABB) -> Double

fn aabb_ray_cast(AABB, Vec2, Vec2) -> RayResult

fn aabb_union(AABB, AABB) -> AABB

fn abs_float(Double) -> Double

fn abs_int(Int) -> Int

fn abs_vec2(Vec2) -> Vec2

fn add(Vec2, Vec2) -> Vec2

fn atan2(Double, Double) -> Double

fn body_apply_force(BodySim, Vec2, Vec2) -> BodySim

fn body_apply_impulse(BodySim, Vec2, Vec2) -> BodySim

fn body_get_local_point(BodySim, Vec2) -> Vec2

fn body_get_local_vector(BodySim, Vec2) -> Vec2

fn body_get_position(BodyId) -> Vec2

fn body_get_rotation(BodyId) -> Rot

fn body_get_shapes(BodyId) -> Array[ShapeId]

fn body_get_type(BodyId) -> BodyType

fn body_get_world_point(BodySim, Vec2) -> Vec2

fn body_get_world_vector(BodySim, Vec2) -> Vec2

fn body_is_valid(BodyId) -> Bool

fn body_set_mass_data(BodySim, MassData) -> BodySim

fn clamp_float(Double, Double, Double) -> Double

fn clamp_int(Int, Int, Int) -> Int

fn clamp_vec2(Vec2, Vec2, Vec2) -> Vec2

fn closest_point_on_segment(Vec2, Vec2, Vec2) -> Vec2

fn collide_capsule_and_circle(Capsule, Transform, Circle, Transform) -> Manifold

fn collide_capsules(Capsule, Transform, Capsule, Transform) -> Manifold

fn collide_chain_segment_and_capsule(ChainSegment, Transform, Capsule, Transform, SimplexCache) -> Manifold

fn collide_chain_segment_and_circle(ChainSegment, Transform, Circle, Transform) -> Manifold

fn collide_chain_segment_and_polygon(ChainSegment, Transform, Polygon, Transform, SimplexCache) -> Manifold

fn collide_circle_capsule(Circle, Transform, Capsule, Transform) -> Manifold

fn collide_circles(Circle, Transform, Circle, Transform) -> Manifold

fn collide_polygon_and_capsule(Polygon, Transform, Capsule, Transform) -> Manifold

fn collide_polygon_and_circle(Polygon, Transform, Circle, Transform) -> Manifold

fn collide_polygons(Polygon, Transform, Polygon, Transform) -> Manifold

fn collide_segment_and_capsule(Segment, Transform, Capsule, Transform) -> Manifold

fn collide_segment_and_circle(Segment, Transform, Circle, Transform) -> Manifold

fn collide_segment_and_polygon(Segment, Transform, Polygon, Transform) -> Manifold

fn compute_capsule_aabb(Capsule, Transform) -> AABB

fn compute_capsule_mass(Capsule, Double) -> MassData

fn compute_circle_aabb(Circle, Transform) -> AABB

fn compute_circle_mass(Circle, Double) -> MassData

fn compute_cos_sin(Double) -> CosSin

fn compute_hull(Array[Vec2]) -> Hull

fn compute_polygon_aabb(Polygon, Transform) -> AABB

fn compute_polygon_centroid(Array[Vec2]) -> Vec2

fn compute_polygon_mass(Polygon, Double) -> MassData

fn compute_segment_aabb(Segment, Transform) -> AABB

fn compute_segment_mass(Segment, Double) -> MassData

fn create_body(WorldId, BodyDef) -> BodyId

fn create_body_sim(BodyDef) -> BodySim

fn create_capsule_shape(BodyId, ShapeDef, Capsule) -> ShapeId

fn create_circle_shape(BodyId, ShapeDef, Circle) -> ShapeId

fn create_distance_joint_sim(DistanceJointDef, Vec2, Vec2) -> JointSim

fn create_polygon_shape(BodyId, ShapeDef, Polygon) -> ShapeId

fn create_prismatic_joint_sim(PrismaticJointDef, Vec2, Vec2, Vec2) -> JointSim

fn create_revolute_joint_sim(RevoluteJointDef, Vec2) -> JointSim

fn create_segment_shape(BodyId, ShapeDef, Segment) -> ShapeId

fn create_world(WorldDef) -> WorldId

fn create_world_from_def(WorldDef) -> World

fn cross(Vec2, Vec2) -> Double

fn cross_sv(Double, Vec2) -> Vec2

fn cross_vs(Vec2, Double) -> Vec2

fn default_body_def() -> BodyDef

fn default_distance_joint_def() -> DistanceJointDef

fn default_prismatic_joint_def() -> PrismaticJointDef

fn default_revolute_joint_def() -> RevoluteJointDef

fn default_shape_def() -> ShapeDef

fn default_world_def() -> WorldDef

fn distance(Vec2, Vec2) -> Double

fn distance_between_points(Vec2, Vec2) -> Double

fn distance_squared(Vec2, Vec2) -> Double

fn dot(Vec2, Vec2) -> Double

fn empty_hull() -> Hull

fn enlarge_aabb(AABB, AABB) -> (AABB, Bool)

fn find_sleepy_bodies(Array[BodySim]) -> Array[Int]

fn get_body_def(BodyId) -> (WorldId, BodyDef)?

fn get_distance_joint_length(JointSim, Array[BodySim]) -> Double

fn get_length_and_normalize(Vec2) -> (Double, Vec2)

fn get_shape_def(ShapeId) -> (BodyId, ShapeDef, ShapeType)?

fn get_sweep_transform(Sweep, Double) -> Transform

fn get_world_def(WorldId) -> WorldDef?

fn hello() -> String

fn integrate_body(BodySim, Double) -> BodySim

fn inv_mul_rot(Rot, Rot) -> Rot

fn inv_mul_transforms(Transform, Transform) -> Transform

fn inv_rotate_vector(Rot, Vec2) -> Vec2

fn inv_transform_point(Transform, Vec2) -> Vec2

fn is_normalized(Vec2) -> Bool

fn is_normalized_rot(Rot) -> Bool

fn is_valid_aabb(AABB) -> Bool

fn is_valid_float(Double) -> Bool

fn is_valid_plane(Plane) -> Bool

fn is_valid_ray(Vec2, Vec2, Double) -> Bool

fn is_valid_rotation(Rot) -> Bool

fn is_valid_transform(Transform) -> Bool

fn is_valid_vec2(Vec2) -> Bool

fn island_add_body(Island, Int) -> Island

fn island_add_contact(Island, Int) -> Island

fn island_add_joint(Island, Int) -> Island

fn left_perp(Vec2) -> Vec2

fn length(Vec2) -> Double

fn length_squared(Vec2) -> Double

fn lerp(Vec2, Vec2, Double) -> Vec2

fn make_box(Double, Double) -> Polygon

fn make_capsule(Vec2, Vec2, Double) -> Capsule

fn make_capsule_horizontal(Double, Double) -> Capsule

fn make_capsule_vertical(Double, Double) -> Capsule

fn make_hexagon(Double) -> Polygon

fn make_id(Int, Int) -> Int

fn make_offset_box(Double, Double, Vec2, Rot, Double) -> Polygon

fn make_offset_polygon(Hull, Vec2, Rot, Double) -> Polygon

fn make_offset_proxy(Array[Vec2], Double, Vec2, Rot) -> ShapeProxy

fn make_pentagon(Double) -> Polygon

fn make_polygon(Hull, Double) -> Polygon

fn make_polygon_box(Double, Double) -> Polygon

fn make_polygon_from_vertices(Array[Vec2], Double) -> Polygon

fn make_polygon_square(Double) -> Polygon

fn make_proxy(Array[Vec2], Double) -> ShapeProxy

fn make_regular_polygon(Int, Double) -> Polygon

fn make_rot(Double) -> Rot

fn make_rot_from_unit_vector(Vec2) -> Rot

fn make_rounded_box(Double, Double, Double) -> Polygon

fn make_segment(Vec2, Vec2) -> Segment

fn make_segment_horizontal(Double) -> Segment

fn make_segment_vertical(Double) -> Segment

fn make_soft(Double, Double, Double) -> Softness

fn make_triangle(Double) -> Polygon

let mat22_zero : Mat22

fn max_float(Double, Double) -> Double

fn max_int(Int, Int) -> Int

fn max_vec2(Vec2, Vec2) -> Vec2

fn merge_islands(Island, Island) -> Island

fn min_float(Double, Double) -> Double

fn min_int(Int, Int) -> Int

fn min_vec2(Vec2, Vec2) -> Vec2

fn mul_add(Vec2, Double, Vec2) -> Vec2

fn mul_rot(Rot, Rot) -> Rot

fn mul_sub(Vec2, Double, Vec2) -> Vec2

fn mul_sv(Double, Vec2) -> Vec2

fn mul_transforms(Transform, Transform) -> Transform

fn mul_vv(Vec2, Vec2) -> Vec2

fn neg(Vec2) -> Vec2

fn neg_float(Double) -> Double

fn normalize(Vec2) -> Vec2

fn normalize_rot(Rot) -> Rot

let pi : Double

fn plane_separation(Plane, Vec2) -> Double

fn point_in_aabb(Vec2, AABB) -> Bool

fn point_in_capsule(Vec2, Capsule, Transform) -> Bool

fn point_in_circle(Vec2, Vec2, Double) -> Bool

fn point_in_polygon(Vec2, Polygon, Transform) -> Bool

fn prepare_distance_joint(JointSim, Array[BodySim], Double) -> JointSim

fn prepare_prismatic_joint(JointSim, Array[BodySim], Double) -> JointSim

fn prepare_revolute_joint(JointSim, Array[BodySim], Double) -> JointSim

fn ray_cast_circle(Circle, RayCastInput) -> RayResult

fn ray_cast_polygon(Polygon, RayCastInput) -> RayResult

fn ray_cast_segment(Segment, RayCastInput, Bool) -> RayResult

fn relative_angle(Rot, Rot) -> Double

fn right_perp(Vec2) -> Vec2

fn rot_get_angle(Rot) -> Double

fn rot_get_x_axis(Rot) -> Vec2

fn rot_get_y_axis(Rot) -> Vec2

let rot_identity : Rot

fn rotate_vector(Rot, Vec2) -> Vec2

fn segment_distance(Vec2, Vec2, Vec2, Vec2) -> SegmentDistanceResult

fn shape_distance(DistanceInput, SimplexCache) -> (DistanceOutput, SimplexCache)

fn shape_is_valid(ShapeId) -> Bool

fn should_wake_on_force(BodySim, Vec2, Double) -> Bool

fn should_wake_on_impulse(BodySim, Vec2, Double) -> Bool

fn sleep_all_bodies(Array[BodySim]) -> Array[BodySim]

fn solve_distance_joint_velocity(JointSim, Array[BodySim], Double, Bool) -> (JointSim, Array[BodySim])

fn solve_prismatic_joint_velocity(JointSim, Array[BodySim], Double, Bool) -> (JointSim, Array[BodySim])

fn solve_revolute_joint_velocity(JointSim, Array[BodySim], Double, Bool) -> (JointSim, Array[BodySim])

let speculative_distance : Double

fn spring_damper(Double, Double, Double, Double, Double) -> Double

fn step_world(World, Double) -> World

fn sub(Vec2, Vec2) -> Vec2

let transform_identity : Transform

fn transform_point(Transform, Vec2) -> Vec2

fn transform_polygon(Transform, Polygon) -> Polygon

fn unwind_angle(Double) -> Double

fn validate_hull(Hull) -> Bool

fn vec2_add(Vec2, Vec2) -> Vec2

fn vec2_dot(Vec2, Vec2) -> Double

fn vec2_length(Vec2) -> Double

let vec2_zero : Vec2

fn wake_all_bodies(Array[BodySim]) -> Array[BodySim]

fn warm_start_distance_joint(JointSim, Array[BodySim]) -> Array[BodySim]

fn warm_start_prismatic_joint(JointSim, Array[BodySim]) -> Array[BodySim]

fn warm_start_revolute_joint(JointSim, Array[BodySim]) -> Array[BodySim]

fn world_get_bodies(WorldId) -> Array[BodyId]

fn world_get_body(World, Int) -> BodySim

fn world_get_body_count(World) -> Int

fn world_get_island_stats(World) -> (Int, Int, Int)

fn world_has_active_islands(World) -> Bool

fn world_is_valid(WorldId) -> Bool

fn world_step(WorldId, Double, Int) -> Unit

// Errors

// Types and methods
pub(all) struct AABB {
  lower_bound : Vec2
  upper_bound : Vec2
}
impl Eq for AABB
impl Show for AABB

pub(all) struct BodyDef {
  mut type_ : BodyType
  mut position : Vec2
  mut rotation : Rot
  mut linear_velocity : Vec2
  mut angular_velocity : Double
  mut linear_damping : Double
  mut angular_damping : Double
  mut gravity_scale : Double
  mut sleep_threshold : Double
  mut enable_sleep : Bool
  mut is_awake : Bool
  mut is_enabled : Bool
}
impl Eq for BodyDef
impl Show for BodyDef

pub(all) struct BodyId {
  id : Int
}
impl Eq for BodyId
impl Show for BodyId

type BodySim
impl Eq for BodySim
impl Show for BodySim

pub(all) struct BodyState {
  linear_velocity : Vec2
  angular_velocity : Double
  flags : Int
}
impl Eq for BodyState
impl Show for BodyState

pub(all) enum BodyType {
  Static
  Kinematic
  Dynamic
}
impl Eq for BodyType
impl Show for BodyType

pub(all) struct Capsule {
  center1 : Vec2
  center2 : Vec2
  radius : Double
}
impl Eq for Capsule
impl Show for Capsule

pub(all) struct ChainSegment {
  ghost1 : Vec2
  segment : Segment
  ghost2 : Vec2
  chain_id : Int
}
impl Eq for ChainSegment
impl Show for ChainSegment

pub(all) struct Circle {
  center : Vec2
  radius : Double
}
impl Eq for Circle
impl Show for Circle

pub struct ContactConstraint {
  body_a_index : Int
  body_b_index : Int
  normal : Vec2
  friction : Double
  restitution : Double
  tangent : Vec2
  points : Array[ContactConstraintPoint]
  point_count : Int
  inv_mass_a : Double
  inv_mass_b : Double
  inv_i_a : Double
  inv_i_b : Double
}
impl Eq for ContactConstraint
impl Show for ContactConstraint

pub struct ContactConstraintPoint {
  r_a : Vec2
  r_b : Vec2
  mut normal_impulse : Double
  mut tangent_impulse : Double
  normal_mass : Double
  tangent_mass : Double
  velocity_bias : Double
  warm_normal_impulse : Double
  warm_tangent_impulse : Double
}
impl Eq for ContactConstraintPoint
impl Show for ContactConstraintPoint

pub struct ContactSolver {
  constraints : Array[ContactConstraint]
  constraint_count : Int
  velocity_iterations : Int
  position_iterations : Int
}
impl Eq for ContactSolver
impl Show for ContactSolver

pub(all) struct CosSin {
  cosine : Double
  sine : Double
}
impl Eq for CosSin
impl Show for CosSin

pub(all) struct DistanceInput {
  proxy_a : ShapeProxy
  proxy_b : ShapeProxy
  transform_a : Transform
  transform_b : Transform
  use_radii : Bool
}
impl Eq for DistanceInput
impl Show for DistanceInput

pub(all) struct DistanceJoint {
  length : Double
  hertz : Double
  damping_ratio : Double
  lower_spring_force : Double
  upper_spring_force : Double
  min_length : Double
  max_length : Double
  max_motor_force : Double
  motor_speed : Double
  mut impulse : Double
  mut lower_impulse : Double
  mut upper_impulse : Double
  mut motor_impulse : Double
  mut index_a : Int
  mut index_b : Int
  mut anchor_a : Vec2
  mut anchor_b : Vec2
  mut delta_center : Vec2
  mut distance_softness : Softness
  mut axial_mass : Double
  enable_spring : Bool
  enable_limit : Bool
  enable_motor : Bool
}
impl Eq for DistanceJoint
impl Show for DistanceJoint

pub(all) struct DistanceJointDef {
  base : JointDef
  mut length : Double
  mut enable_spring : Bool
  mut lower_spring_force : Double
  mut upper_spring_force : Double
  mut hertz : Double
  mut damping_ratio : Double
  mut enable_limit : Bool
  mut min_length : Double
  mut max_length : Double
  mut enable_motor : Bool
  mut max_motor_force : Double
  mut motor_speed : Double
}
impl Eq for DistanceJointDef
impl Show for DistanceJointDef

pub(all) struct DistanceOutput {
  point_a : Vec2
  point_b : Vec2
  distance : Double
  normal : Vec2
  iterations : Int
  simplex_count : Int
}
impl Eq for DistanceOutput
impl Show for DistanceOutput

pub(all) struct Hull {
  points : Array[Vec2]
  count : Int
}
impl Eq for Hull
impl Show for Hull

type Island
impl Eq for Island
impl Show for Island

pub(all) struct Joint {
  joint_type : JointType
  set_index : Int
  color_index : Int
  local_index : Int
  edges : (JointEdge, JointEdge)
  joint_id : Int
  island_id : Int
  island_prev : Int
  island_next : Int
  collide_connected : Bool
}
impl Eq for Joint
impl Show for Joint

pub(all) struct JointDef {
  body_id_a : BodyId
  body_id_b : BodyId
  collide_connected : Bool
}
impl Eq for JointDef
impl Show for JointDef

pub(all) struct JointEdge {
  body_id : Int
  prev_key : Int
  next_key : Int
}
impl Eq for JointEdge
impl Show for JointEdge

pub(all) struct JointId {
  id : Int
}
impl Eq for JointId
impl Show for JointId

pub(all) struct JointSim {
  joint_type : JointType
  body_id_a : Int
  body_id_b : Int
  local_frame_a : Transform
  local_frame_b : Transform
  mut inv_mass_a : Double
  mut inv_mass_b : Double
  mut inv_ia : Double
  mut inv_ib : Double
  mut constraint_softness : Softness
  distance_joint : DistanceJoint
  revolute_joint : RevoluteJoint
  prismatic_joint : PrismaticJoint
}
impl Eq for JointSim
impl Show for JointSim

pub(all) enum JointType {
  DistanceJoint
  MotorJoint
  PrismaticJoint
  RevoluteJoint
  WeldJoint
  WheelJoint
}
impl Eq for JointType
impl Show for JointType

pub(all) struct Manifold {
  normal : Vec2
  rolling_impulse : Double
  points : Array[ManifoldPoint]
  point_count : Int
}
impl Eq for Manifold
impl Show for Manifold

pub(all) struct ManifoldPoint {
  point : Vec2
  anchor_a : Vec2
  anchor_b : Vec2
  separation : Double
  normal_impulse : Double
  tangent_impulse : Double
  total_normal_impulse : Double
  normal_velocity : Double
  id : Int
  persisted : Bool
}
impl Eq for ManifoldPoint
impl Show for ManifoldPoint

pub(all) struct MassData {
  mass : Double
  center : Vec2
  rotational_inertia : Double
}
impl Eq for MassData
impl Show for MassData

pub(all) struct Mat22 {
  cx : Vec2
  cy : Vec2
}
impl Eq for Mat22
impl Show for Mat22

pub(all) struct Plane {
  normal : Vec2
  offset : Double
}
impl Eq for Plane
impl Show for Plane

pub(all) struct Polygon {
  vertices : Array[Vec2]
  normals : Array[Vec2]
  centroid : Vec2
  radius : Double
  count : Int
}
impl Eq for Polygon
impl Show for Polygon

pub(all) struct PrismaticJoint {
  target_translation : Double
  hertz : Double
  damping_ratio : Double
  lower_translation : Double
  upper_translation : Double
  max_motor_force : Double
  motor_speed : Double
  enable_spring : Bool
  enable_limit : Bool
  enable_motor : Bool
  mut impulse : Vec2
  mut spring_impulse : Double
  mut motor_impulse : Double
  mut lower_impulse : Double
  mut upper_impulse : Double
  mut index_a : Int
  mut index_b : Int
  mut frame_a : Transform
  mut frame_b : Transform
  mut delta_center : Vec2
  mut axial_mass : Double
  mut spring_softness : Softness
}
impl Eq for PrismaticJoint
impl Show for PrismaticJoint

pub(all) struct PrismaticJointDef {
  base : JointDef
  mut target_translation : Double
  mut enable_spring : Bool
  mut hertz : Double
  mut damping_ratio : Double
  mut enable_limit : Bool
  mut lower_translation : Double
  mut upper_translation : Double
  mut enable_motor : Bool
  mut max_motor_force : Double
  mut motor_speed : Double
}
impl Eq for PrismaticJointDef
impl Show for PrismaticJointDef

pub(all) struct RayCastInput {
  origin : Vec2
  translation : Vec2
  max_fraction : Double
}
impl Eq for RayCastInput
impl Show for RayCastInput

pub(all) struct RayResult {
  shape_id : ShapeId
  point : Vec2
  normal : Vec2
  fraction : Double
  hit : Bool
}
impl Eq for RayResult
impl Show for RayResult

pub(all) struct RevoluteJoint {
  mut linear_impulse : Vec2
  mut spring_impulse : Double
  mut motor_impulse : Double
  mut lower_impulse : Double
  mut upper_impulse : Double
  hertz : Double
  damping_ratio : Double
  target_angle : Double
  max_motor_torque : Double
  motor_speed : Double
  lower_angle : Double
  upper_angle : Double
  mut index_a : Int
  mut index_b : Int
  mut frame_a : Transform
  mut frame_b : Transform
  mut delta_center : Vec2
  mut axial_mass : Double
  mut spring_softness : Softness
  enable_spring : Bool
  enable_motor : Bool
  enable_limit : Bool
}
impl Eq for RevoluteJoint
impl Show for RevoluteJoint

pub(all) struct RevoluteJointDef {
  base : JointDef
  mut target_angle : Double
  mut enable_spring : Bool
  mut hertz : Double
  mut damping_ratio : Double
  mut enable_limit : Bool
  mut lower_angle : Double
  mut upper_angle : Double
  mut enable_motor : Bool
  mut max_motor_torque : Double
  mut motor_speed : Double
}
impl Eq for RevoluteJointDef
impl Show for RevoluteJointDef

pub(all) struct Rot {
  c : Double
  s : Double
}
impl Eq for Rot
impl Show for Rot

pub(all) struct Segment {
  point1 : Vec2
  point2 : Vec2
}
impl Eq for Segment
impl Show for Segment

pub(all) struct SegmentDistanceResult {
  closest1 : Vec2
  closest2 : Vec2
  distance_squared : Double
  fraction1 : Double
  fraction2 : Double
}
impl Eq for SegmentDistanceResult
impl Show for SegmentDistanceResult

pub(all) struct ShapeDef {
  mut density : Double
  mut friction : Double
  mut restitution : Double
  mut is_sensor : Bool
}
impl Eq for ShapeDef
impl Show for ShapeDef

pub(all) struct ShapeId {
  id : Int
}
impl Eq for ShapeId
impl Show for ShapeId

pub(all) struct ShapeProxy {
  points : Array[Vec2]
  count : Int
  radius : Double
}
impl Eq for ShapeProxy
impl Show for ShapeProxy

pub(all) enum ShapeType {
  Circle
  Capsule
  Polygon
  Segment
  ChainSegment
}
impl Eq for ShapeType
impl Show for ShapeType

pub(all) struct Simplex {
  v1 : SimplexVertex
  v2 : SimplexVertex
  v3 : SimplexVertex
  count : Int
}
impl Eq for Simplex
impl Show for Simplex

pub(all) struct SimplexCache {
  index_a : Array[Int]
  index_b : Array[Int]
  count : Int
}
impl Eq for SimplexCache
impl Show for SimplexCache

pub(all) struct SimplexVertex {
  w_a : Vec2
  w_b : Vec2
  w : Vec2
  a : Double
  index_a : Int
  index_b : Int
}
impl Eq for SimplexVertex
impl Show for SimplexVertex

pub(all) struct Softness {
  bias_rate : Double
  mass_scale : Double
  impulse_scale : Double
}
impl Eq for Softness
impl Show for Softness

pub(all) struct Sweep {
  local_center : Vec2
  c1 : Vec2
  c2 : Vec2
  q1 : Rot
  q2 : Rot
}
impl Eq for Sweep
impl Show for Sweep

pub(all) struct Transform {
  p : Vec2
  q : Rot
}
impl Eq for Transform
impl Show for Transform

pub(all) struct Vec2 {
  x : Double
  y : Double
}
impl Eq for Vec2
impl Show for Vec2

type World
impl Eq for World
impl Show for World

pub(all) struct WorldDef {
  mut gravity : Vec2
  restitution_threshold : Double
  hit_event_threshold : Double
  contact_hertz : Double
  contact_damping_ratio : Double
  maximum_linear_speed : Double
  mut enable_sleep : Bool
  mut enable_continuous : Bool
}
impl Eq for WorldDef
impl Show for WorldDef

pub(all) struct WorldId {
  id : Int
}
impl Eq for WorldId
impl Show for WorldId

// Type aliases

// Traits

